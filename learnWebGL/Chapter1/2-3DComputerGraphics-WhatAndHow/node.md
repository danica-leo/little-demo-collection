# 3D Computer Graphics - What and How

 Raster graphics
 Vector graphics

 光栅图像 / 矢量图像

 Computer-generated imagery （CGI）

 graphic pipeline

 not programmable

 added complexity
 shader

### The graphics pipeline

#### Step1：Input model vertices
normal vector，model vertices，color data

#### Step2：Model view transform

###### vertex shader：a computer program written in GLSL that positions the geometry of models in a scene.
    "Vertex shader"（顶点着色器）是图形处理中的一种程序，主要用于渲染3D图像。它运行在GPU（图形处理单元）上，负责处理3D模型中的每个顶点的数据。顶点着色器的主要任务包括对顶点的位置、颜色、纹理坐标等属性进行计算和变换，以及为下一阶段的图形管线（如几何着色器或片元着色器）准备数据。

    顶点着色器可以通过一些基本的操作，如位移、旋转和缩放，来影响顶点的位置和属性。这些操作通常是根据3D图像的视角和光源等因素进行的，以达到所需的视觉效果。在现代图形API如OpenGL或DirectX中，顶点着色器是可编程的，允许开发者自定义顶点处理逻辑，以创建更复杂和动态的视觉效果。

    GLSL（OpenGL Shading Language，OpenGL着色语言）是用于在OpenGL中编写着色器（如顶点着色器、片元着色器和几何着色器）的高级编程语言。它提供了一种标准方式来编写在图形卡上直接运行的自定义代码，用于图形渲染的各个阶段。

    GLSL使开发者能够详细控制图形渲染过程中的顶点和像素处理。着色器用GLSL编写，允许进行复杂的数学运算和逻辑操作，以实现如光照、阴影、纹理映射、颜色变换等高级视觉效果。

    GLSL的语法类似于C语言，包括数据类型、控制结构和自定义函数等。这种语言允许图形开发者更精细地控制硬件执行的操作，从而可以优化渲染性能和增强图形质量。


#### Step3: Projection Transform 
将3D图像投影到2D画面上

#### Step4: Normalize & Clip Transform
裁截摄像头以外的画面


#### Step5: Viewport Transfrom （GPU: Fixed functionality）
将3d对象与栅格化图像像素点对应起来


“Fixed functionality” 在图形学中通常指的是固定功能流水线（Fixed-function pipeline），这是早期图形渲染技术中的一种特性。在这种模式下，图形硬件（如早期的 GPU）提供了预定义的渲染流程，开发者只能通过调整一些有限的参数来控制渲染效果，而无法像现代可编程着色器那样灵活地控制每个像素或顶点的计算。

### 固定功能流水线的特点
1. **预定义渲染流程**: 所有的渲染步骤，如顶点变换、光照计算、纹理映射等，都是由硬件预先定义好的，开发者只能选择是否开启某些功能或者调节功能的参数。
  
2. **有限的控制**: 开发者只能使用 GPU 提供的一组固定的 API 来设置渲染效果，比如 OpenGL 的早期版本（如 OpenGL 1.0 到 1.4）和 DirectX 7 之前的版本。这种模式下，开发者无法自定义顶点和像素的计算过程。

3. **简单易用**: 由于渲染管线是固定的，对于开发者来说，上手门槛较低，不需要编写复杂的着色器代码。这种模式特别适合一些简单的 3D 应用和游戏开发。

4. **功能受限**: 固定功能流水线由于缺乏灵活性，只能实现一些基础的渲染效果，如基本的光照、简单的纹理映射等。对于复杂的视觉效果，比如自定义的光照模型、后处理效果等，则无能为力。

### 可编程流水线（Programmable Pipeline）
随着图形学的发展，固定功能流水线逐渐被可编程流水线所取代。现代的图形 API（如 OpenGL 2.0+ 和 DirectX 9+）引入了可编程着色器（Shaders），允许开发者在顶点、片段（像素）以及几何等阶段自定义处理逻辑，从而可以实现各种复杂的渲染效果。

### 固定功能流水线的应用场景
尽管现代图形渲染主要依靠可编程流水线，但在一些嵌入式系统或者资源受限的设备中，固定功能流水线仍有其应用价值，因为它能够以更低的复杂度和资源开销实现基本的 3D 渲染功能。

### 总结
“Fixed functionality” 指的是早期的、非可编程的图形渲染模式，特点是渲染步骤和处理方式由硬件预先定义，开发者只能进行有限的参数调整，无法像现代可编程管线那样灵活地控制渲染过程。这种模式简单易用，但功能受限，适用于简单的渲染需求。


#### Step6: Rasterize （GPU: Fixed functionality）

Rasterization is an essential process in computer graphics, especially when converting vector graphics (which use mathematical equations to define shapes) into raster graphics (which use pixels). This process is crucial for rendering images on screens or printing them.

#### Step7：Shading （GPU: Fragment Shader）

“Shader” 翻译成“着色器”而不是“渲染器”，这是因为两者在功能和概念上有明显的区别。

### 1. **Shader（着色器）**
- **定义**: Shader 是一种在图形处理过程中执行特定任务的小程序或代码，用于决定如何计算每个像素、顶点或片段的颜色及其他属性。
- **功能**: 它主要负责“着色”，也就是确定物体表面的颜色、光照、阴影等视觉效果。Shader 本质上是一种编程工具，用来描述如何在一个三维场景中生成二维图像的特定视觉效果。
- **类型**: 常见的 Shader 类型包括顶点着色器（Vertex Shader）、片段着色器（Fragment Shader）和几何着色器（Geometry Shader）。
- **翻译为“着色器”**: 这个翻译强调了 Shader 的核心作用是“着色”，即控制图形如何呈现颜色和光照效果。

### 2. **Renderer（渲染器）**
- **定义**: Renderer 是一种更为综合性的工具或引擎，负责整个图形渲染管线的执行，从物体模型的处理、光照计算到最终的图像生成。
- **功能**: 它是一个完整的图形渲染系统，涵盖了从场景描述、光照计算、材质处理到最终图像输出的全过程。比如我们常用的三维渲染引擎 Unity、Unreal Engine 中的渲染引擎模块。
- **职责范围更广**: 渲染器不仅仅包括着色的过程，还包括视角投影、几何变换、光线追踪等更复杂的场景管理和图形生成功能。
- **翻译为“渲染器”**: 这个翻译更强调整个渲染过程的执行和管理，而不仅仅是颜色计算。

### 总结
- **着色器（Shader）** 强调的是图形管线中如何决定图形表面颜色和光照效果的部分，偏向于“微观”层面。
- **渲染器（Renderer）** 强调的是整个渲染过程，涵盖了从模型数据处理到最终图像输出的完整流程，属于“宏观”层面。

因此，“Shader” 翻译为“着色器”更能准确传达其在图形渲染中所扮演的角色。

#### Step8：Composition



### 常见着色器
顶点着色器（Vertex Shader）、片段着色器（Fragment Shader）和几何着色器（Geometry Shader）是现代图形渲染管线中三种常见的可编程着色器阶段。它们在渲染过程中各自负责不同的任务，但也有一些共同点。以下是对它们各自职责的详细说明及它们之间的异同：

### 1. **顶点着色器（Vertex Shader）**
#### 主要职责
- **顶点处理**: 顶点着色器的主要任务是处理每个输入顶点的数据。它会对顶点进行各种变换操作，如将顶点从模型空间转换到世界空间、视图空间，最终转换到裁剪空间。
- **计算法线和纹理坐标**: 顶点着色器还可以用来计算顶点的法线、纹理坐标等信息，并将这些数据传递到后续的着色器阶段。
- **光照计算**: 可以进行简单的顶点光照计算，比如计算每个顶点的漫反射和镜面反射效果。
  
#### 输入输出
- **输入**: 顶点着色器接受的是每个顶点的数据，如位置、法线、纹理坐标等。
- **输出**: 输出经过变换后的顶点位置和其他要传递给片段着色器的插值数据，如颜色、纹理坐标等。

### 2. **片段着色器（Fragment Shader）**
#### 主要职责
- **像素着色**: 片段着色器的主要任务是决定每个像素的最终颜色。它通常会使用来自纹理的数据、光照信息以及其他插值变量来计算颜色。
- **纹理采样**: 从纹理中读取颜色数据，并将其与光照、材质等信息结合，用来决定像素的最终颜色。
- **处理高级效果**: 可以用来实现各种复杂的像素级效果，如法线贴图、反射、折射、阴影、后期处理等。

#### 输入输出
- **输入**: 片段着色器接受的是每个片段的插值数据，如顶点着色器输出的颜色、纹理坐标等。
- **输出**: 输出最终的像素颜色（颜色值、深度值等），并决定该片段是否要绘制到屏幕上。

### 3. **几何着色器（Geometry Shader）**
#### 主要职责
- **几何处理**: 几何着色器可以在顶点着色器和片段着色器之间对几何体进行处理。它可以生成、修改或删除顶点。
- **生成新几何体**: 它可以将一个原始图元（如点、线段或三角形）扩展为多个图元，比如将一个点扩展为一个四边形、将一条线段扩展为一个棱锥等。
- **修改拓扑结构**: 几何着色器可以改变几何图形的拓扑结构，用于实现如体积渲染、阴影体积（Shadow Volume）等效果。

#### 输入输出
- **输入**: 几何着色器接受一个或多个顶点着色器输出的顶点，可以是点、线段或三角形等原始图元。
- **输出**: 它输出一个或多个新生成的图元，可以是顶点、线段、三角形等。

### 异同点

#### 相同点
1. **可编程性**: 三者都是可编程的着色器，开发者可以通过编写 GLSL、HLSL 或其他着色语言来定义它们的行为。
2. **管线位置**: 它们都处于图形渲染管线中，是 GPU 执行渲染任务的重要组成部分。
3. **数据传递**: 它们之间可以传递数据，如顶点着色器传递数据给几何着色器，几何着色器传递数据给片段着色器。

#### 不同点
1. **处理对象不同**:
   - **顶点着色器**: 处理的是单个顶点数据。
   - **几何着色器**: 处理的是整个图元（点、线段或三角形等）。
   - **片段着色器**: 处理的是每个像素或片段的数据。

2. **输入输出不同**:
   - 顶点着色器输入单个顶点，输出变换后的顶点数据。
   - 几何着色器输入一组顶点（图元），输出新的图元数据。
   - 片段着色器输入插值的顶点数据（每个片段的数据），输出每个像素的最终颜色。

3. **功能侧重不同**:
   - 顶点着色器侧重于几何变换和顶点属性的计算。
   - 几何着色器侧重于几何体的生成和修改。
   - 片段着色器侧重于像素颜色的计算和复杂的视觉效果处理。

### 总结
- **顶点着色器**: 负责顶点的变换和属性计算。
- **片段着色器**: 负责像素的颜色计算和复杂的视觉效果。
- **几何着色器**: 负责几何体的生成和修改。

每种着色器在图形渲染中都有自己特定的任务，但它们又是一个完整渲染管线的一部分，共同协作来实现最终的渲染效果。


# 计算机图形开发，算前端开发吗？
在计算机图形学领域中，是否将其视为“前端开发”取决于具体的上下文和开发场景。

### 1. **传统前端开发的定义**
前端开发通常指的是与用户交互的应用程序界面的开发。它涉及到用户界面的设计和实现，通常包括以下几类技术和内容：
- **Web 前端**: 使用 HTML、CSS 和 JavaScript 来开发用户可以直接在浏览器中交互的页面或应用。
- **移动端前端**: 使用 Swift、Kotlin 或 React Native 等技术开发移动应用的界面部分。
- **桌面应用前端**: 使用像 Electron 这样的框架开发桌面应用的用户界面。

### 2. **计算机图形学的开发**
计算机图形学（Computer Graphics）的开发通常指的是使用特定的图形 API（如 OpenGL、DirectX、Vulkan、WebGL）或图形引擎（如 Unity、Unreal Engine）来创建和渲染三维场景、图像以及其他视觉效果。它通常包括以下几个方面：

- **渲染和着色**: 使用着色器、光照模型、纹理映射等技术来生成逼真的图像。
- **物理模拟**: 模拟现实世界中的物理现象，如刚体碰撞、流体模拟等。
- **场景管理和动画**: 管理三维场景中的对象、相机、动画等元素。

### 3. **图形开发与前端开发的关系**
在某些情况下，计算机图形开发和前端开发有一定的重叠，但它们的侧重点和技术栈不同。

#### 共同点
- **用户体验**: 两者都关注如何为用户提供良好的视觉和交互体验。
- **界面开发**: 都涉及界面元素的开发和布局，只是计算机图形开发中处理的是三维场景中的对象，而传统前端开发中更多是二维界面的布局和交互。
- **编程语言重叠**: 在 WebGL 开发中，计算机图形学使用 JavaScript 和 GLSL，而这些技术也常用于 Web 前端开发。

#### 区别
- **渲染复杂度**: 计算机图形学中处理的是复杂的三维渲染、着色器编程、光照计算等，而前端开发更多是二维的 HTML、CSS、JavaScript 以及相关框架。
- **应用领域**: 图形开发主要应用在游戏开发、视觉特效、虚拟现实等领域；而前端开发主要应用在网站、移动应用等用户界面方面。
- **技术栈**: 计算机图形开发通常需要掌握图形学相关的数学、算法和特定的图形 API；而前端开发更多涉及 Web 技术、前端框架、用户交互设计等。

### 4. **特殊情况：WebGL 和 Three.js 等图形库**
在使用 WebGL 或 Three.js 进行图形开发时，可以认为这是一种将图形开发和前端开发结合的场景：
- **WebGL**: 直接在浏览器中使用 JavaScript 进行三维图形渲染，可以看作前端开发的一部分，因为它在浏览器环境中工作。
- **Three.js**: 这是一个封装了 WebGL 的 JavaScript 库，用于简化三维图形的开发，它也属于前端开发范畴，但同时涉及了很多图形学的知识。

### 总结
- 如果你是在 **浏览器环境中使用 WebGL、Three.js 或其他 JavaScript 图形库** 进行开发，那么这可以看作是前端开发的一部分。
- 如果你是使用 **OpenGL、DirectX、Vulkan** 等图形 API 或者在 **Unity、Unreal Engine** 中进行图形开发，那么这更接近于传统的图形学开发，而不属于典型的前端开发。

所以，计算机图形开发是否算前端开发取决于具体的开发环境和技术栈。Web 环境中的图形开发可以视为前端开发的一部分，而传统的图形渲染和游戏开发则通常不归类为前端开发。